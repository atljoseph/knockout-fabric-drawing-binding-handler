<!DOCTYPE html>
<html>
<head>
    <script src="fabric.js" type="text/javascript"></script>
    <script src="knockout.js" type="text/javascript"></script>
    <script src="jquery.min.js" type="text/javascript"></script>
    <title></title>
	<meta charset="utf-8" />
    <style>
        .bordered {
            border: solid black 1px;
        }
    </style>
</head>
<body>

    <table>
        <tr style="vertical-align: top;">
            <td style="padding: 10px">

                <h2>Control Actions</h2>
                <button data-bind="click: drawing.canvas.clear">Clear the Drawing</button><br>
                <button data-bind="click: function() { console.log(drawing.canvas.valueJSON()); }">Show JSON</button><br>

                <h2>Drag / Draw</h2>
                <label>Sawp Between Drag and Draw &nbsp;<input type="checkbox" data-bind="checked: drawing.canvas.draggable" value="true"></label><br>
                <button data-bind="click: drawing.canvas.deleteSelected">Delete selected object</button><br>

                <h2>Control Properties</h2>
                <label>Height</label>
                <input type="text" data-bind="textInput: drawing.canvas.height"/><br>
                <label>Width</label>
                <input type="text" data-bind="textInput: drawing.canvas.width"/><br>
                <label>Name</label>
                <input type="text" data-bind="textInput: drawing.canvas.name"/><br>
                <label>Brush Color</label>
                <input type="text" data-bind="textInput: drawing.brush.color"/><br>
                <label>Brush Width</label>
                <input type="text" data-bind="textInput: drawing.brush.width"/><br>

                <h2>Signature Line</h2>
                <label>Visible? &nbsp;<input type="checkbox" data-bind="checked: drawing.line.visible" value="true"></label><br>
                <label>Width</label>
                <input type="text" data-bind="textInput: drawing.line.width"/><br>
                <label>Color</label>
                <input type="text" data-bind="textInput: drawing.line.color"/><br>
                <label>Offset X</label>
                <input type="text" data-bind="textInput: drawing.line.offsetX"/><br>
                <label>Offset y</label>
                <input type="text" data-bind="textInput: drawing.line.offsetY"/><br>

            </td>
            <td style="padding: 10px">
                <h2>Control Model</h2>
                <label>Value Raw</label><br>
                <textarea data-bind="value: drawing.canvas.valueJSON" style="width: 225px; height: 250px;"></textarea><br>
                <label>ImageURL Raw</label><br>
                <textarea data-bind="value: drawing.canvas.image64" style="width: 225px; height: 250px;"></textarea><br>
            </td> 
            <td style="padding: 10px">
                <div style="position: fixed;">
                    <h2>Drawing Area</h2>
                    <canvas class="bordered" data-bind="fabricDrawing: drawing"></canvas><br>
                    <h2>Rendered Image</h2>
                    <img data-bind="attr:{ src: drawing.canvas.image64 }" class="bordered" style="width: 67%;"/>
                </div>
            </td>
                   
        </tr>
    </table>

    <script>
        ko.bindingHandlers.fabricDrawing = {
            init: function(element, valueAccessor, allBindings, viewModel, bindingContext){
                var d = this;

                // TODO:
                ////////////////////////////////////////////////
                // MAKE THE SIGNATURE LINE INTO AN OBSERVABLE
                // ADD ABILITY TO EDIT DRAWING BRUSH


                // instantiate the canvas object
                d.canvas = this.__canvas = new fabric.Canvas(element);


                //
                // draggable/selectable vs. drawing mode ?
                // console.log(d.controlNameObservable());
                d.controlDraggableObservable = valueAccessor().canvas.draggable;
                d.controlDraggableObservable.subscribe(function(newValue){
                    //console.log(newValue);
                    d.canvas.isDrawingMode = !newValue;
                    d.canvas.selection = newValue;
                    d.canvas.forEachObject(function(o) {
                        if(o.type == 'path'){
                            o.selectable = newValue;
                        }
                    });
                    d.canvas.renderAll.bind(d.canvas);
                });
                d.controlDraggableObservable.valueHasMutated();

                //
                // manually apply binding of id and name of element with controlNAmeObservable
                // console.log(d.controlNameObservable());
                d.controlNameObservable = valueAccessor().canvas.name;
                ko.applyBindingsToNode(element, { attr: { name: d.controlNameObservable, id: d.controlNameObservable } } );
                d.controlNameObservable.subscribe(function(newValue){
                    // console.log(newValue);
                    console.log(element.name);
                });
                d.controlNameObservable.valueHasMutated();

                //
                // the actual value observable for control:
                // apply a default for initialization purposes
                // console.log(d.controlValueObservable());
                d.controlValueObservable = valueAccessor().canvas.value;
                d.controlValueObservable(d.controlValueObservable() || []);
                d.controlValueObservable.subscribe(function(newValue){
                    //console.log(d.canvas.toDatalessJSON());
                    //console.log(newValue);
                });

                //
                // the actual image base 64 observable representation of the user input on this drawing control instance
                // apply a default for initialization purposes
                // console.log(d.controlImage64Observable());
                d.controlImage64Observable = valueAccessor().canvas.image64;
                d.controlImage64Observable.subscribe(function(newValue){
                    //console.log(d.canvas.toDataURL());
                    //console.log(newValue);
                    // console.log(newValue.length);
                });
                d.controlImage64Observable('data:image/png;base64,');

                //
                // this might be a default value, or it could be data to populate a drawing (for editing or viewing) from the database
                // console.log(d.controlInitialStaticValue);
                d.controlInitialStaticValue = valueAccessor().canvas.initial;
                if (d.controlInitialStaticValue){
                    d.canvas.loadFromJSON(d.controlInitialStaticValue, d.canvas.renderAll.bind(d.canvas));
                    d.controlValueObservable(d.controlInitialStaticValue);
                }

                //
                // the actual width of the control
                // for image (display mode) or drawing (input mode)
                // apply the bindings to the root node
                // console.log(d.controlWidthObservable());
                d.controlWidthObservable = valueAccessor().canvas.width;
                ko.applyBindingsToNode(element, { attr: { width: d.controlWidthObservable } } );
                d.controlWidthObservable.subscribe(function(newValue){
                    // console.log(newValue);
                    d.canvas.setWidth(parseInt(newValue));
                    d.canvas.calcOffset();
                    //d.canvas.renderAll.bind(d.canvas);
                });
                d.controlWidthObservable.valueHasMutated();

                //
                // the actual height of the control
                // for image (display mode) or drawing (input mode)
                // console.log(d.controlHeightObservable());
                d.controlHeightObservable = valueAccessor().canvas.height;
                ko.applyBindingsToNode(element, { attr: { height: d.controlHeightObservable() + 'px' } } );
                d.controlHeightObservable.subscribe(function(newValue){
                    // console.log(newValue);
                    d.canvas.setHeight(parseInt(newValue));
                    d.canvas.calcOffset();
                    //d.canvas.renderAll.bind(d.canvas);
                });
                d.controlHeightObservable.valueHasMutated();

                // //
                // // the actual display mode of the control
                // // for image (display mode) or drawing (input mode)
                // d.controlModeObservable = valueAccessor().canvas.mode;
                // d.controlModeObservable.subscribe(function(newValue){
                //     console.log(newValue);
                // });

                d.updateSigLine = function(){
                    if (d.sigLineStaticObject){
                        d.sigLineStaticObject.set({
                            x1: parseInt(d.sigLineOffsetXObservable()),
                            y1: parseInt(d.controlHeightObservable() - d.sigLineOffsetYObservable()),
                            x2: parseInt(d.controlWidthObservable() - d.sigLineOffsetXObservable()),
                            y2: parseInt(d.controlHeightObservable() - d.sigLineOffsetYObservable()),
                            fill: d.sigLineColorObservable(),
                            stroke: d.sigLineColorObservable(),
                            strokeWidth: parseInt(d.sigLineWidthObservable()),
                            visible: d.sigLineVisibleObservable()
                        });
                        d.canvas.trigger('mouse:down', {});
                        d.canvas.renderAll.bind(d.canvas);
                        // d.canvas.setActiveObject(d.sigLineStaticObject);
                        // console.log('signature line updated');
                    }
                    // else{
                    //     console.log('signature line not updated because it hasn\'t been added to the canvas yet);
                    // }
                }

                //
                // the actual width of the optional signature line of the control
                d.sigLineWidthObservable = valueAccessor().line.width;
                d.sigLineWidthObservable.subscribe(function(newValue){
                    // console.log(newValue);
                    d.updateSigLine();
                });

                //
                // the actual color of the optional signature line of the control
                d.sigLineColorObservable = valueAccessor().line.color;
                d.sigLineColorObservable.subscribe(function(newValue){
                    // console.log(newValue);
                    d.updateSigLine();
                });

                //
                // the offset in the x direction of the optional signature line of the control
                d.sigLineOffsetXObservable = valueAccessor().line.offsetX;
                d.sigLineOffsetXObservable.subscribe(function(newValue){
                    // console.log(newValue);
                    d.updateSigLine();
                });

                //
                // the offset in the y direction of the optional signature line of the control
                d.sigLineOffsetYObservable = valueAccessor().line.offsetY;
                d.sigLineOffsetYObservable.subscribe(function(newValue){
                    // console.log(newValue);
                    d.updateSigLine();
                });

                //
                // the visibility of the optional signature line of the control
                d.sigLineVisibleObservable = valueAccessor().line.visible;
                d.sigLineVisibleObservable.subscribe(function(newValue){
                    // console.log(newValue);
                    d.updateSigLine();
                });

                function signatureLine() {
                    var coords = [
                        parseInt(d.sigLineOffsetXObservable()),
                        parseInt(d.controlHeightObservable() - d.sigLineOffsetYObservable()),
                        parseInt(d.controlWidthObservable() - d.sigLineOffsetXObservable()),
                        parseInt(d.controlHeightObservable() - d.sigLineOffsetYObservable()),
                    ];
                    // // var coords = [25, 130, 450, 130];
                    // console.log(coords);
                    var sigLine = new fabric.Line(coords, {
                        fill: d.sigLineColorObservable(),
                        stroke: d.sigLineColorObservable(),
                        strokeWidth: parseInt(d.sigLineWidthObservable()),
                        selectable: false,
                        visible: d.sigLineVisibleObservable()
                    });
                    // console.log(sigLine);
                    return sigLine;
                }
                d.sigLineStaticObject = new signatureLine();
                d.canvas.add(d.sigLineStaticObject);
                // simulate a setting change to fire the update
                //d.sigLineWidthObservable.valueHasMutated();


                //
                // the actual width of the drawing line of the control
                d.brushWidthObservable = valueAccessor().brush.width;
                d.brushWidthObservable.subscribe(function(newValue){
                    // console.log(newValue);
                });
                d.brushWidthObservable.valueHasMutated();

                //
                // the actual color of the drawing line of the control
                d.brushColorObservable = valueAccessor().brush.color;
                d.brushColorObservable.subscribe(function(newValue){
                    // console.log(newValue);
                });
                d.brushColorObservable.valueHasMutated();

                //
                // update items from the canvas into the model
                // console.log('updateModel');
                d.updateModel = function(){
                    d.controlValueObservable(d.canvas.toDatalessJSON());
                    d.controlImage64Observable(d.canvas.toDataURL());
                }

                //
                // this is kind of a reverse binding experiment
                // bind the dummy variable function from the control
                // to the canvas clear function used internally in this handler
                // console.log(valueAccessor().canvas.clear);
                valueAccessor().canvas.clear = function(resetInitialValueBool){
                    // console.log('clearing canvas, and view model. If "resetInitialValueBool" is true, then the initial value will be restored.');
                    if(resetInitialValueBool && d.controlInitialStaticValue){
                        // load the json and automatically update the canvas
                        d.canvas.loadFromJSON(d.controlInitialStaticValue, d.canvas.renderAll.bind(d.canvas));
                    }
                    else{
                        d.canvas.clear();
                    }
                    d.sigLineStaticObject = new signatureLine();
                    d.canvas.add(d.sigLineStaticObject);
                    d.updateModel();
                }

                //
                // this is kind of a reverse binding experiment
                // bind the dummy variable function from the control
                // to the canvas deleteSelected function used internally in this handler
                // console.log(valueAccessor().canvas.deleteSelected);
                valueAccessor().canvas.deleteSelected = function(){
                    var selected = d.canvas.getActiveObject();
                    if (selected){
                        selected.remove();
                    }

                }

                //
                // this funtion activates the bindings with fabric for this handler
                d.activateBinding = function(){
                    // listen to the canvas for drawing updates
                    ko.utils.arrayForEach(['mouse:down', 'mouse:up'],
                        function(eventName){
                            d.canvas.on(eventName, function(e){
                                // console.log(eventName);
                                d.updateModel();
                        });
                    });
                    // automatically update the brush width & color of new drawings to the currently selected color
                    ko.utils.arrayForEach(['object:added'],  //'path:created',
                        function(eventName){
                            d.canvas.on(eventName, function(e){
                                if (e.target.type == 'path'){
                                    var lastDrawing = e.target;
                                    lastDrawing.set({
                                        // the fill variable will literally fill in any circle you draw
                                        // cool, but unintended consequences
                                        // fill: d.brushColorObservable(),
                                        stroke: d.brushColorObservable(),
                                        strokeWidth: parseInt(d.brushWidthObservable())
                                    });
                                    // d.canvas.renderAll.bind(d.canvas);
                                }

                        });
                    });
                }

                // listen to the canvas for drawing updates
                d.activateBinding();

                return d;
            }
        }
    </script>

    <script>

        var dummyInitialValue = '{"objects":[{"type":"path","originX":"center","originY":"center","left":289.71,"top":108,"width":365.41,"height":144,"fill":null,"stroke":"rgb(0, 0, 0)","strokeWidth":1,"strokeDashArray":null,"strokeLineCap":"round","strokeLineJoin":"round","strokeMiterLimit":10,"scaleX":1,"scaleY":1,"angle":0,"flipX":false,"flipY":false,"opacity":1,"shadow":null,"visible":true,"clipTo":null,"backgroundColor":"","fillRule":"nonzero","globalCompositeOperation":"source-over","transformMatrix":null,"skewX":0,"skewY":0,"pathOffset":{"x":289.70710678118655,"y":108},"path":[["M",471.5,36],["Q",471.5,36,472,36],["Q",472.5,36,472.25,36],["Q",472,36,470.5,36],["Q",469,36,465,38.5],["Q",461,41,456.5,44],["Q",452,47,442,52.5],["Q",432,58,418,67],["Q",404,76,392,82.5],["Q",380,89,361.5,98.5],["Q",343,108,327,116],["Q",311,124,297.5,130.5],["Q",284,137,265,144.5],["Q",246,152,238.5,155.5],["Q",231,159,224,160.5],["Q",217,162,211,164.5],["Q",205,167,200,168],["Q",195,169,187.5,170],["Q",180,171,174.5,173],["Q",169,175,163.5,176],["Q",158,177,154.5,177.5],["Q",151,178,149,178],["Q",147,178,144,178],["Q",141,178,139,179],["Q",137,180,135,180],["Q",133,180,131,180],["Q",129,180,128,180],["Q",127,180,126,180],["Q",125,180,123,180],["Q",121,180,119.5,180],["Q",118,180,116.5,179],["Q",115,178,113.5,178],["Q",112,178,111.5,177.5],["Q",111,177,110,177],["Q",109,177,108.5,176.5],["Q",108,176,107.5,176],["Q",107,176,107,175.5],["Q",107,175,107,175],["Q",107,175,107,174.5],["L",107,174]]},{"type":"path","originX":"center","originY":"center","left":353.5,"top":111.5,"width":117,"height":131,"fill":null,"stroke":"rgb(0, 0, 0)","strokeWidth":1,"strokeDashArray":null,"strokeLineCap":"round","strokeLineJoin":"round","strokeMiterLimit":10,"scaleX":1,"scaleY":1,"angle":0,"flipX":false,"flipY":false,"opacity":1,"shadow":null,"visible":true,"clipTo":null,"backgroundColor":"","fillRule":"nonzero","globalCompositeOperation":"source-over","transformMatrix":null,"skewX":0,"skewY":0,"pathOffset":{"x":353.5,"y":111.5},"path":[["M",295.5,46],["Q",295.5,46,296,46],["Q",296.5,46,296.25,46],["Q",296,46,296,46.5],["Q",296,47,296,47],["Q",296,47,295.5,47],["Q",295,47,295,48],["Q",295,49,295,49.5],["Q",295,50,295,51],["Q",295,52,295,53.5],["Q",295,55,295,56],["Q",295,57,295,58.5],["Q",295,60,295,61.5],["Q",295,63,295,65],["Q",295,67,295,69],["Q",295,71,295.5,73],["Q",296,75,296,77],["Q",296,79,296.5,81],["Q",297,83,297,85],["Q",297,87,298.5,89],["Q",300,91,300.5,93],["Q",301,95,302.5,97.5],["Q",304,100,306.5,102],["Q",309,104,311.5,106],["Q",314,108,318,110.5],["Q",322,113,325.5,114.5],["Q",329,116,334.5,118],["Q",340,120,344,122],["Q",348,124,351.5,125.5],["Q",355,127,358,129],["Q",361,131,363.5,132.5],["Q",366,134,368,135],["Q",370,136,372.5,137],["Q",375,138,379,140.5],["Q",383,143,386,146],["Q",389,149,392,152],["Q",395,155,397,157.5],["Q",399,160,400,162],["Q",401,164,403,165.5],["Q",405,167,406,168.5],["Q",407,170,408,170.5],["Q",409,171,409,172.5],["Q",409,174,409.5,174.5],["Q",410,175,410.5,175.5],["Q",411,176,411.5,176],["Q",412,176,412,176.5],["Q",412,177,412,177],["L",412,177]]}]}';

        dummyInitialValue = '';

        function drawingCanvasViewModel() {
            var d = this;
            d.canvas = {
                    visible: ko.observable(true),
                    draggable: ko.observable(false),
                    name: ko.observable('drawing-1'),
                    initial: dummyInitialValue,
                    value: ko.observable(),
                    image64: ko.observable(),
                    width: ko.observable('350'),
                    height: ko.observable('200'),
                    clear: function(){ console.log('dummy clear function'); },
                    deleteSelected: function(){ console.log('dummy deleteSelected function'); },
            };
            d.line = {
                    visible: ko.observable(false),
                    width: ko.observable('2'),
                    color: ko.observable('blue'),
                    offsetX: ko.observable('30'),
                    offsetY: ko.observable('20'),
            };
            d.brush = {
                    width: ko.observable('3'),
                    color: ko.observable('green'),
            };

            // computed
            d.canvas.valueJSON = ko.computed(function(){
                var value = [];
                if (d.canvas.value()){
                    value = d.canvas.value();
                }
                return ko.toJSON(value);
            });

            return d;
        }

        var drawing = new drawingCanvasViewModel();
        ko.applyBindings(drawing);
    </script>

</body>
</html>
